<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>reveal.js</title>

    <link rel="stylesheet" href="dist/reset.css">
    <link rel="stylesheet" href="dist/reveal.css">
    <link rel="stylesheet" href="dist/theme/black.css">

    <!-- Theme used for syntax highlighted code -->
    <link rel="stylesheet" href="plugin/highlight/monokai.css">
    <style>
        .grid-area {
            display: grid;
            grid-auto-flow: column;
        }

        .reveal pre code {
            max-height: none;
        }

        .reveal pre {
            width: 100%;
        }

        .inline-image img {
            margin: 0;
        }

        .inline-image {
            display: inline-flex;
        }
    </style>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section data-timing="60">
            <h1>Functional Kotlin</h1>
            <p>
                <img style="vertical-align: middle" alt="kotlin logo" src="kotlin-logo.png" height="120" width="120">
                <span style="vertical-align: middle; font-size: 2em;">+</span>
                <img style="vertical-align: middle" alt="lambda" src="lambda.png" height="120" width="120">
            </p>
            <aside class="notes">

            </aside>
        </section>
        <section data-timing="30s">
            <h1>About Me</h1>
            <aside class="notes">
                You can also find me on the Chicago Tech and Kotlin slacks and the CJUG discord
            </aside>
            <h3>John Burns</h3>
            <div class="grid-area">
                <div style="text-align: left">
                    <p>Staff Engineer @ GrubHub</p>
                    <p>CKUG Co-Organizer</p>
                    <p>ktlint-gradle Maintainer</p>
                    <p class="inline-image"><img alt="twitter logo" src="Twitter-Logo.png" height="48" width="48"/>
                        <span style="padding-left: .5em; padding-right: 2em;">@wakingrufus</span>
                        <img alt="github logo" src="github-logo.png" height="48" width="48"/>
                        <span style="padding-left: .5em">wakingrufus</span></p>
                    <p class="inline-image"><img alt="fediverse logo" src="fediverse.png" height="48" width="48"/>
                        <span style="padding-left: .5em">@wakingrufus@bigshoulders.city</span>
                    </p>
                </div>
            </div>
        </section>
        <section data-timing="60">
            <img alt="GrubHub logo" src="gh-logo.png" height="194" width="688">
            <aside class="notes">
                HQ is chicago
                we have been publicly traded and operating off our own revenue and profits since 2014
                What I do: Service Platform Engineering: JVM Stewardship
            </aside>
            <ul>
                <li>Unlimited PTO</li>
                <li>8-16 weeks of parental leave</li>
                <li>4.5 day work week</li>
            </ul>
        </section>
        <section data-timing="90">
            <h1>About You</h1>
            <h4 class="fragment">Experienced with OOP Java</h4>
            <h4 class="fragment">Experienced with Functional Programming</h4>
            <h4 class="fragment">Experienced with Kotlin</h4>
            <h4 class="fragment">Experienced with FP + Kotlin</h4>
            <aside class="notes">

            </aside>
        </section>
        <section> <!-- What is Functional Programming? -->
            <section data-auto-animate data-timing="30">
                <h2>What is Functional Programming?</h2>
                <aside class="notes">
                    Some people know FP only as collection operations, filter/map
                    this is just one particular impl of FP
                    i will define it in practical term, not mathematical
                </aside>
            </section>
            <section data-auto-animate data-timing="90">
                <h2>What is Functional Programming?</h2>
                <h4>Similar Principles as OOP</h4>
                <aside class="notes">
                    Function and OO are not at odds
                    they share many of the same principles
                </aside>
                <ul>
                    <li class="fragment">Encapsulation</li>
                    <li class="fragment">DRY</li>
                    <li class="fragment">GoF Design Patterns</li>
                    <li class="fragment">Favor composition over inheritance</li>
                </ul>
            </section>
            <section data-auto-animate data-timing="90">
                <h2>What is Functional Programming?</h2>
                <h4>Differences from OOP</h4>
                <aside class="notes">
                    But there are some differences
                </aside>
                <ul>
                    <li class="fragment">Verbs vs Nouns</li>
                    <li class="fragment">Limit mutable state</li>
                </ul>
            </section>
            <section data-auto-animate data-timing="60">
                <h2>What is Functional Programming?</h2>
                <h4>What is a functional language?</h4>
                <aside class="notes">
                    these principals can apply to any language, so what makes a functional lang?
                    for us, it doesn't matter
                    java and kotlin are both multiparadigm
                    you can write kotlin just like OOP Java
                    you can mix FP with OOP
                </aside>
                <ul>
                    <li class="fragment">Java and Kotlin are multi-paradigm</li>
                    <li class="fragment">real world projects are rarely pure OOP or FP</li>
                </ul>
            </section>
            <section data-auto-animate data-timing="60">
                <h2>What is Functional Programming?</h2>
                <h4>Functional Core, Imperative Shell</h4>
                <aside class="notes">
                    real programs have side effects
                    No program is 100% pure functional
                    Push state out to the ‘edges’.
                    Place application’s core data and logic in immutable constructs (value types).
                    Represent state as objects with mutable references to immutable core constructs.
                    Shell: OOP, state, IO, Side effects, GUI
                    Core: Pure functions, stateless, logic
                </aside>
                <ul>
                    <li class="fragment">Shell: OOP, state, IO, Side effects, GUI</li>
                    <li class="fragment">Core: Pure functions, stateless, logic</li>
                </ul>
            </section>
        </section>
        <section> <!-- what makes kotlin more functional -->
            <section data-auto-animate data-timing="30">
                <h2>What Makes Kotlin more "Functional"?</h2>
                <aside class="notes">
                    so how much of your code is core vs shell?
                    in kotlin, a higher ratio of core is possible
                    Certain FP concepts are easier, or default in Kotlin
                </aside>
                <ul>
                    <li class="fragment">Kotlin gives us more tools for FP</li>
                </ul>
            </section>
            <section data-auto-animate data-timing="60">
                <h2>What Makes Kotlin more "Functional"?</h2>
                <aside class="notes">
                    Very quickly, I want to outline some examples
                </aside>
                <ul>
                    <li class="fragment">Pure Functions</li>
                    <li class="fragment">Immutable Data</li>
                    <li class="fragment">"First-class" Functions</li>
                    <li class="fragment">Functional Types</li>
                    <li class="fragment">Higher Order Functions</li>
                    <li class="fragment">Type System</li>
                </ul>
            </section>
        </section>
        <section> <!-- Immutable Data -->
            <section data-auto-animate data-timing="90">
                <h2>Immutable Data</h2>
                <aside class="notes">
                    Value of Values by Rich Hickey
                    in OOP classes have data and behavior
                    in FP, keep state and behavior separate (class / function)
                    we like immutable data classes for the following benefits
                </aside>
                <ul>
                    <li class="fragment">Thread safe</li>
                    <li class="fragment">Avoids temporal coupling</li>
                    <li class="fragment">No need for defensive copies</li>
                    <li class="fragment">Helps prevent side effects</li>
                    <li class="fragment">Easier to cache</li>
                </ul>
            </section>
            <section data-auto-animate data-timing="90">
                <h2>Immutable Data</h2>
                <aside class="notes">
                    in java we need getters, tostring, eq hashcode
                    you can use lombok or ide to generate
                    in kotlin, its first class keyword "data class"
                    val/var forces mutability choice, vs
                    java which make mutable default and needs "final" for immutable
                </aside>
                <pre class="kotlin"><code data-trim data-noescape>
data class ImmutableDataValue(val stringData: String)
                </code></pre>
            </section>
        </section>
        <section> <!-- pure functions -->
            <section data-auto-animate data-timing="30">
                <h2>Pure Functions</h2>
                <aside class="notes">
                    Pure functions can be written in java or kotlin
                    its a good practice in both
                </aside>
                <ul>
                    <li class="fragment">Deterministic: Same inputs will always yield same outputs</li>
                    <li class="fragment">No Side-Effects: Do not access or mutate shared state</li>
                </ul>
            </section>
            <section data-auto-animate data-timing="30">
                <h2>Pure Functions</h2>
                <h4 data-id="subtitle">Non-Deterministic</h4>
                <aside class="notes">

                </aside>
                <pre class="kotlin"><code data-trim data-noescape>
data class ChatMessage(
    val user: String
    val timestamp: Instant
    val message: String)


fun newMessage(message: String) : ChatMessage {
  return ChatMessage(
    user = System.getProperty("user.name"),
    timestamp = Instant.now(),
    message = message)
}
                </code></pre>
            </section>
            <section data-auto-animate data-timing="30s">
            <h2>Pure Functions</h2>
            <h4 data-id="subtitle">Deterministic</h4>
            <aside class="notes">

            </aside>
            <pre class="kotlin"><code data-trim data-noescape>
data class ChatMessage(
    val user: String
    val timestamp: Instant
    val message: String)

fun newMessage(
    message: String,
    user: String,
    timestamp: Instant) : ChatMessage {
  return ChatMessage(
    user = user,
    timestamp = timestamp,
    message = message)
}
                </code></pre>
        </section>
            <section data-auto-animate data-timing="30">
            <h2>Pure Functions</h2>
            <h4 data-id="subtitle">Side Effects</h4>
            <aside class="notes">

            </aside>
            <pre class="kotlin"><code data-trim data-noescape>
fun addNewMessageSideEffect(
    messages: MutableList&ltChatMessage>,
    newMessage: ChatMessage) {
  messages.add(newMessage)
  // Modifies input
}

val externalMessages: List&ltChatMessage> = ArrayList()

fun addNewMessageSideEffect2(newMessage: ChatMessage) {
  externalMessages.add(newMessage)
  // Modifies something outside of scope
}
                </code></pre>
        </section>
            <section data-auto-animate data-timing="30">
            <h2>Pure Functions</h2>
            <h4 data-id="subtitle">No Side Effects</h4>
            <aside class="notes">
            transition out: How does kotlin make this easier?
                by giving us first class functions
            </aside>
            <pre class="kotlin"><code data-trim data-noescape>
fun addNewMessage(
    messages: List&ltChatMessage>,
    newMessage: ChatMessage) : List&ltChatMessage> {
  return listOf(*messages.toTypedArray(), newMessage)
}
                </code></pre>
        </section>
        </section>
        <section> <!-- first class functions -->
            <section data-auto-animate data-timing="180">
                <h2>First-Class Functions</h2>
                <aside class="notes">
                    Java -> static util classes
                    statics are ok in this case
                    kotlins first class function eliminate the need for statics
                    kotlin has no statics, which prevents misuse, and covers the 1 good use
                </aside>
                <pre class="java fragment"><code data-trim data-noescape>
                    class BigDecimalUtil {
                        private BigDecimalUtil() { }
                        static boolean bigDecimalEquals(BigDecimal one, BigDecimal two) {
                            return one.compareTo(two) == 0;
                        }
                    }
                </code></pre>
                <pre class="kotlin fragment"><code data-trim data-noescape>
fun bigDecimalEquals(one: BigDecimal, two: BigDecimal) : Boolean {
  return one.compareTo(two) == 0
}

fun bigDecimalEquals(one: BigDecimal, two: BigDecimal) : Boolean
    = one.compareTo(two) == 0

val bigDecimalEquals: (Int, Int) -> Boolean
    = { one, two -> one.compareTo(two) == 0 }
                </code></pre>
            </section>
        </section>
        <section> <!-- functional types -->
            <section data-auto-animate data-timing="90">
                <h2>Functional Types</h2>
                <aside class="notes">
                    In java, func interfaces let us inline impls as lambdas
                    in kotlin, we can express the SAM sig as a type
                </aside>
                <ul>
                    <li class="fragment">@FunctionalInterface</li>
                    <li class="fragment">Automatically match SAM params</li>
                    <li class="fragment">Allow you to declare functional params</li>
                </ul>
            </section>
            <section data-auto-animate data-timing="60">
                <h2>Functional Types</h2>
                <aside class="notes">
                    first, lets look at java
                </aside>
                <pre class="java fragment"><code data-trim data-noescape>
                    static &lt;T> boolean contains(
                            Collection&lt;T> collection,
                            Predicate&lt;T> predicate) {
                        for(T i: collection){
                            if(predicate.test(i)){
                                return true;
                            }
                        }
                        return false;
                    }
                </code></pre>
                <pre class="java fragment"><code data-trim data-noescape>
                    contains(
                        Arrays.asList("1", "2", "10"),
                        (test) -> test.length() > 1
                    ); // true
                </code></pre>
                <pre class="java fragment"><code data-trim data-noescape>
                    @FunctionalInterface
                    public interface Predicate&lt;T> {
                        boolean test(T var1);
                    }
                </code></pre>
            </section>
            <section data-auto-animate data-timing="90">
                <h2>Functional Types</h2>
                <aside class="notes">

                </aside>
                <pre class="kotlin"><code data-trim data-noescape data-line-numbers="3">
                    fun &lt;T> boolean contains(
                            collection: Collection&lt;T>,
                            predicate: (T) -> Boolean) {
                        for(T i: collection){
                            if(predicate(i)){
                                return true;
                            }
                        }
                        return false;
                    }
                </code></pre>
                <pre class="kotlin fragment"><code data-trim data-noescape>
                    contains(Arrays.asList("1", "2", "10")) {
                        it.length() > 1
                    } // true
                </code></pre>
            </section>
        </section>

        <section> <!-- higher order functions -->
            <section data-auto-animate data-timing="30">
                <h2>Higher-Order Functions</h2>
                <aside class="notes">

                </aside>
                <ul>
                    <li class="fragment">Take a function as an input</li>
                    <li class="fragment">Return a function as output</li>
                </ul>
            </section>
            <section data-auto-animate data-timing="200">
                <h2>Higher-Order Functions</h2>
                <aside class="notes">
                    abstract code structure.
                    Encapsulate more abstract concepts,
                    this is why adv. FP has all these complex concepts
                </aside>
                <pre class="kotlin"><code data-trim data-noescape>
                    fun &lt;T> twice(f: (T)->T) : (T)->T = { t -> f(f(t))}

                    fun addThree(x: Int) = x + 3

                    val addThreeTwice : (T) -> T = twice(::addThree)

                    addThreeTwice(7) // 13
                </code></pre>
            </section>
            <section data-auto-animate data-timing="120">
                <h2>Higher-Order Functions</h2>
                <h4>Common Examples</h4>
                <aside class="notes">
                    I could spend the rest of my time talking about these examples.
                    But there are great resources online about each of these, look them up.
                    I want to instead spend some time on another important feature of kotlin for FP
                    In your FP journey, you might spend a year or more just wrapping your head around higher order functions
                    if you do that, you will start to see repeated patterns, and that's when it is time to take the next step
                </aside>
                <ul>
                    <li class="fragment">Kotlin Scope Functions (let, apply, etc)</li>
                    <li class="fragment">Collection Operations (map, filter, etc)</li>
                    <li class="fragment">Memoize</li>
                    <li class="fragment">Lazy delegate</li>
                </ul>
            </section>
        </section>
        <section> <!-- Types -->
            <section data-auto-animate data-timing="120">
                <h2>Types</h2>
                <aside class="notes">
                    Types might sound like an OOP concept to you, but they are an important part of both paradigms
                    How does the type system help you write functional code?
                    OOP defines structure with DI, and which classes methods live on
                    in FP, you have just a bunch of functions, so types provide structure
                </aside>
                <ul>
                    <li class="fragment">Nullability</li>
                    <li class="fragment">Sealed Classes</li>
                    <li class="fragment">Pattern Matching</li>
                </ul>
            </section>
            <section data-auto-animate data-timing="45">
                <h2>Types</h2>
                <h4>Nullability</h4>
                <aside class="notes">
                </aside>
                <pre class="kotlin"><code data-trim data-noescape>
                    var s : String?
                    s = null // OK
                    var s : String
                    s = null // Compile Error
                </code></pre>
            </section>
            <section data-auto-animate data-timing="45">
                <h2>Types</h2>
                <h4>Sealed Classes</h4>
                <aside class="notes">
                </aside>
                <pre class="kotlin"><code data-trim data-noescape>
sealed class Thing {
    class Thing1(val thing1: String): Thing()
    class Thing2(val thing2: Int) : Thing()
}
                </code></pre>
            </section>
            <section data-auto-animate data-timing="45">
                <h2>Types</h2>
                <h4>Pattern Matching</h4>
                <aside class="notes">
                </aside>
                <pre class="kotlin"><code data-trim data-noescape>
                    val thing: Thing
                    when(thing){
                        is Thing1 -> thing.thing1 // String
                        is Thing2 -> thing.thing2 // Int
                    }
                </code></pre>
            </section>
        </section>
        <section> <!-- Monads -->
            <section data-auto-animate data-timing="90">
                <h2>Monads</h2>
                <aside class="notes">
                    I will try to break the monadic curse
                    Monads are important to FP b/c they wrap our common higher order functions into something more tangible,
                    and make them composable
                    they are easy to apply another higher order function to, and retain the same type
                    think Optional.or() or Stream.map in java
                </aside>
                <ul>
                    <li class="fragment">Higher-order function as an object</li>
                    <li class="fragment">Composable</li>
                </ul>
            </section>
            <section data-auto-animate data-timing="60">
                <h2>Monads</h2>
                <h4>Optional</h4>
                <aside class="notes">
                    Java optionals abstract over null-check
                    Kotlin bakes this into nullable types, but its still a monad, we just have nice syntax sugar around it
                </aside>
                <pre class="java"><code data-trim data-noescape>
final var opt = Optional.ofNullable(...);
opt.isPresent(); // true or false
opt.or(fallback);
opt.map(String::length).orElse(0);
                </code></pre>
                <pre class="kotlin"><code data-trim data-noescape>
val opt: String? = ...
opt != null
opt ?: fallback
opt?.length ?: 0
                </code></pre>
            </section>
            <section data-auto-animate data-timing="120">
                <h2>Monads</h2>
                <h4>Either</h4>
                <aside class="notes">
                </aside>
                <pre class="kotlin"><code data-trim data-noescape>
sealed class Either&lt;A, B> {
    class Left&lt;A, B>(val value: A) : Either&lt;A, B>()
    class Right&lt;A, B>(val value: B) : Either&lt;A, B>()
}
val e : Either&lt;String, Int>
when(e){
    is Left -> e.length > 2
    is Right -> e > 2
}
                </code></pre>
            </section>
            <section data-auto-animate data-timing="120">
                <h2>Monads</h2>
                <h4>Try</h4>
                <aside class="notes">
                    throwing exceptions is a side effect.
                    we need to avoid it so that our functions truly only have a single defined return value (pure)
                    no NPE, no other exceptions, etc
                </aside>
                <pre class="kotlin"><code data-trim data-noescape>
sealed class Try&lt;A> {
    class Success&lt;A>(val value: A) : Try&lt;A>()
    class Failure&lt;A>(val ex: Exception) : Try&lt;A>()
}

fun &lt;A> doTry(work: () -> A): Try&lt;A> {
    return try {
        Try.Success(work())
    } catch (e: Exception) {
        Try.Failure(e)
    }
}
val result = doTry { "" }
when (result) {
    is Try.Failure -> result.ex
    is Try.Success -> result.value
}
                </code></pre>
            </section>
            <section data-auto-animate data-timing="45">
                <h2>Types</h2>
                <h4>Other</h4>
                <aside class="notes">
                </aside>
                <ul>
                    <li>Java's CompletableFuture</li>
                    <li>ArrowKt's IO</li>
                    <li>Collections</li>
                </ul>
            </section>
        </section>
        <section> <!-- railway -->
            <section data-auto-animate data-timing="60">
                <h2>Railway-Oriented Programming</h2>
                <aside class="notes">
                    Try is so powerful, the concept of just chaining them together has created a whole new paradigm
                </aside>
<img src="RailwaySwitch3.png" />
                <p>Credit: Scott Wlaschin</p>
                <p><a href="https://fsharpforfunandprofit.com">fsharpforfunandprofit.com</a></p>
            </section>
            <section data-auto-animate data-timing="200">
                <h2>Railway-Oriented Programming</h2>
                <h4>Monad Chains</h4>
                <aside class="notes">
                    transition out: what if the chained lambda is a try
                </aside>
                <pre class="kotlin"><code data-trim data-noescape>
fun &lt;A, B> Try&lt;A>.andThen(next: (A) -> B): Try&lt;B> {
    return when (this) {
        is Try.Success -> doTry { next(this.value) }
        is Try.Failure -> Try.Failure&lt;B>(this.exception)
    }
}
val result = doTry { "" }
    .andThen { it.length }
    .andThen { it + 2 }
    .andThen {  it < 0 }
when (result) {
    is Try.Failure -> result.exception
    is Try.Success -> result.value
}
                </code></pre>
            </section>
            <section data-auto-animate data-timing="60">
                <h2>Railway-Oriented Programming</h2>
                <h4>Monad Chains</h4>
                <aside class="notes">

                </aside>
                <pre class="kotlin"><code data-trim data-noescape>
fun myFunct1(s: String) : Try&lt;Int> = doTry { it.length }
fun &lt;A, B> Try&lt;A>.flatMap(next: (A) -> Try&lt;B>): Try&lt;B> {
    return when (this) {
        is Try.Success -> next(this.value)
        is Try.Failure -> Try.Failure&lt;B>(this.exception)
    }
}
val result = doTry { "" }
    .flatMap { myFunc1(it) }
when (result) {
    is Try.Failure -> result.exception
    is Try.Success -> result.value
}
                </code></pre>
            </section>
        </section>
        <section> <!-- testing -->
            <section data-auto-animate data-timing="60">
                <h2>Testing</h2>
                <aside class="notes">
                    DI is a pattern very commonly used in Object-Oriented Java.
                    It is sometimes done using frameworks such as Dagger, Spring, or Guice,
                    and sometimes plain constructor injection.
                    One of the major benefits of dependency injection is that it gives you the ability to isolate a
                    class for testing by injecting mocks.
                    </aside>
            </section>
            <section data-auto-animate data-timing="60">
                <h2>Testing</h2>
                <aside class="notes">
                    For example: FizzBuzzRunner will print to System.out in production,
                    but we can inject a mock PrintStream for testing.
                </aside>
                <pre class="kotlin"><code data-trim data-noescape>
class FizzBuzzRunner( val linePrinter: PrintStream = System.out) {

  fun fizzBuzz(limit: Int) {
    for(i in 1..limit) {
      linePrinter.println(calculateValueForNumber(i))
    }
  }

  fun calculateValueForNumber(number: Int) : String {
    val sb = StringBuilder()
    if (number % 3 == 0) {  sb.append("FIZZ") }
    if (number % 5 == 0) {  sb.append("BUZZ") }
    if (sb.isEmpty()) {  sb.append(number) }
    return sb.toString()
  }
}
                </code></pre>
            </section>
            <section data-auto-animate data-timing="90">
                <h2>Testing</h2>
                <aside class="notes">
                    Now lets look at an FP example
                    print function has isolated output side effect, but now its directly called, can't mock
                    What do? component test?
                    yes but makes edge cases harder to test
                </aside>
                <pre class="kotlin"><code data-trim data-noescape>
fun fizzBuzz(limit: Int) {
  for(i in 1..limit) {
    print(calculateValueForNumber(i))
  }
}


fun calculateValueForNumber(number: Int) : String {
  val sb = StringBuilder()
  if (number % 3 == 0) {  sb.append("FIZZ") }
  if (number % 5 == 0) {  sb.append("BUZZ") }
  if (sb.isEmpty()) {  sb.append(number) }
  return sb.toString()
}


fun print(string: String) {
  System.out.println(string)
}
                </code></pre>
            </section>
            <section data-auto-animate data-timing="60">
                <h2>Testing</h2>
                <aside class="notes">

                </aside>
                <pre class="kotlin"><code data-trim data-noescape>
fun fizzBuzz(
    limit: Int,
    printer: (String) -> Unit = ::print
) {
  for(i in 1..limit) {
    printer.invoke(calculateValueForNumber(i))
  }
}
                </code></pre>
                <pre class="kotlin"><code data-trim data-noescape>
fizzBuzz(4)
                </code></pre>
                <pre class="kotlin"><code data-trim data-noescape>
fun test() {
  val outputList = mutableListOf&lt;String>()
  fizzBuzz(6) { outputList.add(it) }
  assertThat(outputList[2]).isEqualTo("FIZZ")
}
                </code></pre>
            </section>
        </section>
        <section>
            <h2>More Resources</h2>
            <ul>
                <li>
                    <a href="https://wakingrufus.neocities.org/adhoc-polymorphism.html">Using Ad-hoc Polymorphism to Test Functional Kotlin</a> - Me
                </li>
                <li>
                    <a href="https://wakingrufus.neocities.org/staticwebarticle">Static Web Development with Kotlin DSLs</a> - Me
                </li>
                <li>
                    <a href="https://fsharpforfunandprofit.com/posts/recipe-part2/">Railway oriented programming</a> - Scott Wlaschin
                </li>
                <li>
                    <a href="http://www.yegor256.com/2014/06/09/objects-should-be-immutable.html">Objects Should Be Immutable</a> - <a href="http://www.yegor256.com/">Yegor Bugayenko</a>
                </li>
                <li>
                    <a href="https://www.infoq.com/presentations/Value-Values">The Value of Values</a> - <a href="https://twitter.com/richhickey">Rich Hickey</a>
                </li>
                <li>
                    <a href="https://gist.github.com/kbilsted/abdc017858cad68c3e7926b03646554e">Functional Core, Imperative Shell</a> - <a href="http://firstclassthoughts.co.uk/">Kasper B. Graversen</a>
                </li>
                <li>
                    <a href="https://kotlinexpertise.com/coping-with-kotlins-scope-functions/">Coping with Kotlin's Scope Functions</a> - <a href="https://simon-wirtz.de/">Simon Wirtz</a>
                </li>
            </ul>
        </section>
        <section data-timing="10">
            <div class="grid-area">
                <div style="text-align: left">
                    <div><a href="https://wakingrufus.github.io/functional-kotlin/">https://wakingrufus.github.io/functional-kotlin/</a></div>
                    <p class="inline-image"><img alt="twitter logo" src="Twitter-Logo.png" height="48" width="48"/>
                        <span style="padding-left: .5em; padding-right: 2em;">@wakingrufus</span>
                        <img alt="github logo" src="github-logo.png" height="48" width="48"/>
                        <span style="padding-left: .5em">wakingrufus</span></p>
                    <p class="inline-image"><img alt="fediverse logo" src="fediverse.png" height="48" width="48"/>
                        <span style="padding-left: .5em">@wakingrufus@bigshoulders.city</span>
                    </p>
                </div>
            </div>
        </section>
    </div>
</div>

<script src="dist/reveal.js"></script>
<script src="plugin/notes/notes.js"></script>
<script src="plugin/markdown/markdown.js"></script>
<script src="plugin/highlight/highlight.js"></script>
<script>
    // More info about initialization & config:
    // - https://revealjs.com/initialization/
    // - https://revealjs.com/config/
    Reveal.initialize({
        hash: true,
        defaultTiming: 60,
        // Learn about plugins: https://revealjs.com/plugins/
        plugins: [RevealMarkdown, RevealHighlight, RevealNotes]
    });
</script>
</body>
</html>
